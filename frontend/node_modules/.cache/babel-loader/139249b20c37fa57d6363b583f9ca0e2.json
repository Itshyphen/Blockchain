{"ast":null,"code":"'use strict';\n\nconst protobuf = require('protobufjs/minimal');\n\nconst {\n  PBLink\n} = require('./dag');\n\nconst {\n  createDagLinkFromB58EncodedHash\n} = require('./dag-link/util');\n/**\n * @typedef {import('./dag-link/dagLink')} DAGLink\n * @typedef {import('./types').DAGLinkLike} DAGLinkLike\n * @typedef {import('./types').SerializableDAGNode} SerializableDAGNode\n * @typedef {import('cids')} CID\n */\n\n/**\n * @param { { Data?: Uint8Array, Links: (DAGLink | DAGLinkLike)[] }} node\n * @returns {SerializableDAGNode}\n */\n\n\nconst toProtoBuf = node => {\n  const pbn = {};\n\n  if (node.Data && node.Data.byteLength > 0) {\n    pbn.Data = node.Data;\n  } else {\n    // NOTE: this has to be null in order to match go-ipfs serialization\n    // `null !== new Uint8Array(0)`\n    pbn.Data = null;\n  }\n\n  if (node.Links && node.Links.length > 0) {\n    pbn.Links = node.Links.map(link => ({\n      Hash: link.Hash.bytes,\n      Name: link.Name,\n      Tsize: link.Tsize\n    }));\n  } else {\n    pbn.Links = null;\n  }\n\n  return pbn;\n};\n/**\n * Serialize internal representation into a binary PB block.\n *\n * @param {import('./dag-node/dagNode')} node - Internal representation of a PB block\n */\n\n\nconst serializeDAGNode = node => {\n  return encode(toProtoBuf(node));\n};\n/**\n * Serialize an object where the `Links` might not be a `DAGLink` instance yet\n *\n * @param {Uint8Array} [data]\n * @param {(DAGLink | string | DAGLinkLike)[]} [links]\n */\n\n\nconst serializeDAGNodeLike = (data, links = []) => {\n  const node = {\n    Data: data,\n    Links: links.map(link => {\n      return createDagLinkFromB58EncodedHash(link);\n    })\n  };\n  return encode(toProtoBuf(node));\n};\n\nmodule.exports = {\n  serializeDAGNode,\n  serializeDAGNodeLike\n};\n/**\n * The fields in PBNode are the wrong way round - `id: 2` comes before\n * `id: 1`. protobufjs writes them out in id order but go-IPFS does not so\n * we have to use the protobuf.Writer interface directly to get the same\n * serialized form as go-IPFS\n *\n * @param {SerializableDAGNode} pbf\n */\n\nfunction encode(pbf) {\n  const writer = protobuf.Writer.create();\n\n  if (pbf.Links != null) {\n    for (let i = 0; i < pbf.Links.length; i++) {\n      PBLink.encode(pbf.Links[i], writer.uint32(18).fork()).ldelim();\n    }\n  }\n\n  if (pbf.Data != null) {\n    writer.uint32(10).bytes(pbf.Data);\n  }\n\n  return writer.finish();\n}","map":{"version":3,"sources":["/home/ranju/location/meDossier/frontend/node_modules/ipfs-http-client/node_modules/ipld-dag-pb/src/serialize.js"],"names":["protobuf","require","PBLink","createDagLinkFromB58EncodedHash","toProtoBuf","node","pbn","Data","byteLength","Links","length","map","link","Hash","bytes","Name","Tsize","serializeDAGNode","encode","serializeDAGNodeLike","data","links","module","exports","pbf","writer","Writer","create","i","uint32","fork","ldelim","finish"],"mappings":"AAAA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,oBAAD,CAAxB;;AACA,MAAM;AACJC,EAAAA;AADI,IAEFD,OAAO,CAAC,OAAD,CAFX;;AAIA,MAAM;AACJE,EAAAA;AADI,IAEFF,OAAO,CAAC,iBAAD,CAFX;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AACA,MAAMG,UAAU,GAAIC,IAAD,IAAU;AAC3B,QAAMC,GAAG,GAAG,EAAZ;;AAEA,MAAID,IAAI,CAACE,IAAL,IAAaF,IAAI,CAACE,IAAL,CAAUC,UAAV,GAAuB,CAAxC,EAA2C;AACzCF,IAAAA,GAAG,CAACC,IAAJ,GAAWF,IAAI,CAACE,IAAhB;AACD,GAFD,MAEO;AACL;AACA;AACAD,IAAAA,GAAG,CAACC,IAAJ,GAAW,IAAX;AACD;;AAED,MAAIF,IAAI,CAACI,KAAL,IAAcJ,IAAI,CAACI,KAAL,CAAWC,MAAX,GAAoB,CAAtC,EAAyC;AACvCJ,IAAAA,GAAG,CAACG,KAAJ,GAAYJ,IAAI,CAACI,KAAL,CACTE,GADS,CACJC,IAAD,KAAW;AACdC,MAAAA,IAAI,EAAED,IAAI,CAACC,IAAL,CAAUC,KADF;AAEdC,MAAAA,IAAI,EAAEH,IAAI,CAACG,IAFG;AAGdC,MAAAA,KAAK,EAAEJ,IAAI,CAACI;AAHE,KAAX,CADK,CAAZ;AAMD,GAPD,MAOO;AACLV,IAAAA,GAAG,CAACG,KAAJ,GAAY,IAAZ;AACD;;AAED,SAAOH,GAAP;AACD,CAvBD;AAyBA;AACA;AACA;AACA;AACA;;;AACA,MAAMW,gBAAgB,GAAIZ,IAAD,IAAU;AACjC,SAAOa,MAAM,CAACd,UAAU,CAACC,IAAD,CAAX,CAAb;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMc,oBAAoB,GAAG,CAACC,IAAD,EAAOC,KAAK,GAAG,EAAf,KAAsB;AACjD,QAAMhB,IAAI,GAAG;AACXE,IAAAA,IAAI,EAAEa,IADK;AAEXX,IAAAA,KAAK,EAAEY,KAAK,CAACV,GAAN,CAAWC,IAAD,IAAU;AACzB,aAAOT,+BAA+B,CAACS,IAAD,CAAtC;AACD,KAFM;AAFI,GAAb;AAOA,SAAOM,MAAM,CAACd,UAAU,CAACC,IAAD,CAAX,CAAb;AACD,CATD;;AAWAiB,MAAM,CAACC,OAAP,GAAiB;AACfN,EAAAA,gBADe;AAEfE,EAAAA;AAFe,CAAjB;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,MAAT,CAAiBM,GAAjB,EAAsB;AACpB,QAAMC,MAAM,GAAGzB,QAAQ,CAAC0B,MAAT,CAAgBC,MAAhB,EAAf;;AAEA,MAAIH,GAAG,CAACf,KAAJ,IAAa,IAAjB,EAAuB;AACrB,SAAK,IAAImB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,GAAG,CAACf,KAAJ,CAAUC,MAA9B,EAAsCkB,CAAC,EAAvC,EAA2C;AACzC1B,MAAAA,MAAM,CAACgB,MAAP,CAAcM,GAAG,CAACf,KAAJ,CAAUmB,CAAV,CAAd,EAA4BH,MAAM,CAACI,MAAP,CAAc,EAAd,EAAkBC,IAAlB,EAA5B,EAAsDC,MAAtD;AACD;AACF;;AAED,MAAIP,GAAG,CAACjB,IAAJ,IAAY,IAAhB,EAAsB;AACpBkB,IAAAA,MAAM,CAACI,MAAP,CAAc,EAAd,EAAkBf,KAAlB,CAAwBU,GAAG,CAACjB,IAA5B;AACD;;AAED,SAAOkB,MAAM,CAACO,MAAP,EAAP;AACD","sourcesContent":["'use strict'\n\nconst protobuf = require('protobufjs/minimal')\nconst {\n  PBLink\n} = require('./dag')\n\nconst {\n  createDagLinkFromB58EncodedHash\n} = require('./dag-link/util')\n\n/**\n * @typedef {import('./dag-link/dagLink')} DAGLink\n * @typedef {import('./types').DAGLinkLike} DAGLinkLike\n * @typedef {import('./types').SerializableDAGNode} SerializableDAGNode\n * @typedef {import('cids')} CID\n */\n\n/**\n * @param { { Data?: Uint8Array, Links: (DAGLink | DAGLinkLike)[] }} node\n * @returns {SerializableDAGNode}\n */\nconst toProtoBuf = (node) => {\n  const pbn = {}\n\n  if (node.Data && node.Data.byteLength > 0) {\n    pbn.Data = node.Data\n  } else {\n    // NOTE: this has to be null in order to match go-ipfs serialization\n    // `null !== new Uint8Array(0)`\n    pbn.Data = null\n  }\n\n  if (node.Links && node.Links.length > 0) {\n    pbn.Links = node.Links\n      .map((link) => ({\n        Hash: link.Hash.bytes,\n        Name: link.Name,\n        Tsize: link.Tsize\n      }))\n  } else {\n    pbn.Links = null\n  }\n\n  return pbn\n}\n\n/**\n * Serialize internal representation into a binary PB block.\n *\n * @param {import('./dag-node/dagNode')} node - Internal representation of a PB block\n */\nconst serializeDAGNode = (node) => {\n  return encode(toProtoBuf(node))\n}\n\n/**\n * Serialize an object where the `Links` might not be a `DAGLink` instance yet\n *\n * @param {Uint8Array} [data]\n * @param {(DAGLink | string | DAGLinkLike)[]} [links]\n */\nconst serializeDAGNodeLike = (data, links = []) => {\n  const node = {\n    Data: data,\n    Links: links.map((link) => {\n      return createDagLinkFromB58EncodedHash(link)\n    })\n  }\n\n  return encode(toProtoBuf(node))\n}\n\nmodule.exports = {\n  serializeDAGNode,\n  serializeDAGNodeLike\n}\n\n/**\n * The fields in PBNode are the wrong way round - `id: 2` comes before\n * `id: 1`. protobufjs writes them out in id order but go-IPFS does not so\n * we have to use the protobuf.Writer interface directly to get the same\n * serialized form as go-IPFS\n *\n * @param {SerializableDAGNode} pbf\n */\nfunction encode (pbf) {\n  const writer = protobuf.Writer.create()\n\n  if (pbf.Links != null) {\n    for (let i = 0; i < pbf.Links.length; i++) {\n      PBLink.encode(pbf.Links[i], writer.uint32(18).fork()).ldelim()\n    }\n  }\n\n  if (pbf.Data != null) {\n    writer.uint32(10).bytes(pbf.Data)\n  }\n\n  return writer.finish()\n}\n"]},"metadata":{},"sourceType":"script"}