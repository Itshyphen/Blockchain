{"ast":null,"code":"'use strict';\n\nconst CID = require('cids');\n\nconst uint8ArrayEquals = require('uint8arrays/equals');\n/**\n * @typedef {import('../dag-link/dagLink')} DAGLink\n */\n\n/**\n *\n * @param {import('./dagNode')} dagNode\n * @param {string | CID | Uint8Array | DAGLink} nameOrCid\n */\n\n\nconst rmLink = (dagNode, nameOrCid) => {\n  let predicate = null; // It's a name\n\n  if (typeof nameOrCid === 'string') {\n    predicate = (\n    /** @type {DAGLink} */\n    link) => link.Name === nameOrCid;\n  } else if (nameOrCid instanceof Uint8Array) {\n    predicate = (\n    /** @type {DAGLink} */\n    link) => uint8ArrayEquals(link.Hash.bytes, nameOrCid);\n  } else if (CID.isCID(nameOrCid)) {\n    predicate = (\n    /** @type {DAGLink} */\n    link) => uint8ArrayEquals(link.Hash.bytes, nameOrCid.bytes);\n  }\n\n  if (predicate) {\n    const links = dagNode.Links;\n    let index = 0;\n\n    while (index < links.length) {\n      const link = links[index];\n\n      if (predicate(link)) {\n        links.splice(index, 1);\n      } else {\n        index++;\n      }\n    }\n  } else {\n    throw new Error('second arg needs to be a name or CID');\n  }\n};\n\nmodule.exports = rmLink;","map":{"version":3,"sources":["/home/ranju/location/meDossier/frontend/node_modules/ipfs-http-client/node_modules/ipld-dag-pb/src/dag-node/rmLink.js"],"names":["CID","require","uint8ArrayEquals","rmLink","dagNode","nameOrCid","predicate","link","Name","Uint8Array","Hash","bytes","isCID","links","Links","index","length","splice","Error","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,GAAG,GAAGC,OAAO,CAAC,MAAD,CAAnB;;AACA,MAAMC,gBAAgB,GAAGD,OAAO,CAAC,oBAAD,CAAhC;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AACA,MAAME,MAAM,GAAG,CAACC,OAAD,EAAUC,SAAV,KAAwB;AACrC,MAAIC,SAAS,GAAG,IAAhB,CADqC,CAGrC;;AACA,MAAI,OAAOD,SAAP,KAAqB,QAAzB,EAAmC;AACjCC,IAAAA,SAAS,GAAG;AAAC;AAAuBC,IAAAA,IAAxB,KAAiCA,IAAI,CAACC,IAAL,KAAcH,SAA3D;AACD,GAFD,MAEO,IAAIA,SAAS,YAAYI,UAAzB,EAAqC;AAC1CH,IAAAA,SAAS,GAAG;AAAC;AAAuBC,IAAAA,IAAxB,KAAiCL,gBAAgB,CAACK,IAAI,CAACG,IAAL,CAAUC,KAAX,EAAkBN,SAAlB,CAA7D;AACD,GAFM,MAEA,IAAIL,GAAG,CAACY,KAAJ,CAAUP,SAAV,CAAJ,EAA0B;AAC/BC,IAAAA,SAAS,GAAG;AAAC;AAAuBC,IAAAA,IAAxB,KAAiCL,gBAAgB,CAACK,IAAI,CAACG,IAAL,CAAUC,KAAX,EAAkBN,SAAS,CAACM,KAA5B,CAA7D;AACD;;AAED,MAAIL,SAAJ,EAAe;AACb,UAAMO,KAAK,GAAGT,OAAO,CAACU,KAAtB;AACA,QAAIC,KAAK,GAAG,CAAZ;;AACA,WAAOA,KAAK,GAAGF,KAAK,CAACG,MAArB,EAA6B;AAC3B,YAAMT,IAAI,GAAGM,KAAK,CAACE,KAAD,CAAlB;;AACA,UAAIT,SAAS,CAACC,IAAD,CAAb,EAAqB;AACnBM,QAAAA,KAAK,CAACI,MAAN,CAAaF,KAAb,EAAoB,CAApB;AACD,OAFD,MAEO;AACLA,QAAAA,KAAK;AACN;AACF;AACF,GAXD,MAWO;AACL,UAAM,IAAIG,KAAJ,CAAU,sCAAV,CAAN;AACD;AACF,CA1BD;;AA4BAC,MAAM,CAACC,OAAP,GAAiBjB,MAAjB","sourcesContent":["'use strict'\n\nconst CID = require('cids')\nconst uint8ArrayEquals = require('uint8arrays/equals')\n\n/**\n * @typedef {import('../dag-link/dagLink')} DAGLink\n */\n\n/**\n *\n * @param {import('./dagNode')} dagNode\n * @param {string | CID | Uint8Array | DAGLink} nameOrCid\n */\nconst rmLink = (dagNode, nameOrCid) => {\n  let predicate = null\n\n  // It's a name\n  if (typeof nameOrCid === 'string') {\n    predicate = (/** @type {DAGLink} */ link) => link.Name === nameOrCid\n  } else if (nameOrCid instanceof Uint8Array) {\n    predicate = (/** @type {DAGLink} */ link) => uint8ArrayEquals(link.Hash.bytes, nameOrCid)\n  } else if (CID.isCID(nameOrCid)) {\n    predicate = (/** @type {DAGLink} */ link) => uint8ArrayEquals(link.Hash.bytes, nameOrCid.bytes)\n  }\n\n  if (predicate) {\n    const links = dagNode.Links\n    let index = 0\n    while (index < links.length) {\n      const link = links[index]\n      if (predicate(link)) {\n        links.splice(index, 1)\n      } else {\n        index++\n      }\n    }\n  } else {\n    throw new Error('second arg needs to be a name or CID')\n  }\n}\n\nmodule.exports = rmLink\n"]},"metadata":{},"sourceType":"script"}