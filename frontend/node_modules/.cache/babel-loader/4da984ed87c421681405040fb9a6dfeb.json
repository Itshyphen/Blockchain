{"ast":null,"code":"'use strict';\n\nconst CID = require('cids');\n\nconst uint8ArrayFromString = require('uint8arrays/from-string');\n/**\n * Link represents an IPFS Merkle DAG Link between Nodes.\n */\n\n\nclass DAGLink {\n  /**\n   * @param {string | undefined | null} name\n   * @param {number} size\n   * @param {CID | string | Uint8Array} cid\n   */\n  constructor(name, size, cid) {\n    if (!cid) {\n      throw new Error('A link requires a cid to point to');\n    } // assert(size, 'A link requires a size')\n    //  note - links should include size, but this assert is disabled\n    //  for now to maintain consistency with go-ipfs pinset\n\n\n    this.Name = name || '';\n    this.Tsize = size;\n    this.Hash = new CID(cid);\n    Object.defineProperties(this, {\n      _nameBuf: {\n        value: null,\n        writable: true,\n        enumerable: false\n      }\n    });\n  }\n\n  toString() {\n    return `DAGLink <${this.Hash.toBaseEncodedString()} - name: \"${this.Name}\", size: ${this.Tsize}>`;\n  }\n\n  toJSON() {\n    if (!this._json) {\n      this._json = Object.freeze({\n        name: this.Name,\n        size: this.Tsize,\n        cid: this.Hash.toBaseEncodedString()\n      });\n    }\n\n    return Object.assign({}, this._json);\n  } // Memoize the Uint8Array representation of name\n  // We need this to sort the links, otherwise\n  // we will reallocate new Uint8Arrays every time\n\n\n  get nameAsBuffer() {\n    if (this._nameBuf != null) {\n      return this._nameBuf;\n    }\n\n    this._nameBuf = uint8ArrayFromString(this.Name);\n    return this._nameBuf;\n  }\n\n}\n\nmodule.exports = DAGLink;","map":{"version":3,"sources":["/home/ranju/location/meDossier/frontend/node_modules/ipfs-http-client/node_modules/ipld-dag-pb/src/dag-link/dagLink.js"],"names":["CID","require","uint8ArrayFromString","DAGLink","constructor","name","size","cid","Error","Name","Tsize","Hash","Object","defineProperties","_nameBuf","value","writable","enumerable","toString","toBaseEncodedString","toJSON","_json","freeze","assign","nameAsBuffer","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,GAAG,GAAGC,OAAO,CAAC,MAAD,CAAnB;;AACA,MAAMC,oBAAoB,GAAGD,OAAO,CAAC,yBAAD,CAApC;AAEA;AACA;AACA;;;AACA,MAAME,OAAN,CAAc;AACZ;AACF;AACA;AACA;AACA;AACEC,EAAAA,WAAW,CAAEC,IAAF,EAAQC,IAAR,EAAcC,GAAd,EAAmB;AAC5B,QAAI,CAACA,GAAL,EAAU;AACR,YAAM,IAAIC,KAAJ,CAAU,mCAAV,CAAN;AACD,KAH2B,CAK5B;AACA;AACA;;;AACA,SAAKC,IAAL,GAAYJ,IAAI,IAAI,EAApB;AACA,SAAKK,KAAL,GAAaJ,IAAb;AACA,SAAKK,IAAL,GAAY,IAAIX,GAAJ,CAAQO,GAAR,CAAZ;AAEAK,IAAAA,MAAM,CAACC,gBAAP,CAAwB,IAAxB,EAA8B;AAC5BC,MAAAA,QAAQ,EAAE;AAAEC,QAAAA,KAAK,EAAE,IAAT;AAAeC,QAAAA,QAAQ,EAAE,IAAzB;AAA+BC,QAAAA,UAAU,EAAE;AAA3C;AADkB,KAA9B;AAGD;;AAEDC,EAAAA,QAAQ,GAAI;AACV,WAAQ,YAAW,KAAKP,IAAL,CAAUQ,mBAAV,EAAgC,aAAY,KAAKV,IAAK,YAAW,KAAKC,KAAM,GAA/F;AACD;;AAEDU,EAAAA,MAAM,GAAI;AACR,QAAI,CAAC,KAAKC,KAAV,EAAiB;AACf,WAAKA,KAAL,GAAaT,MAAM,CAACU,MAAP,CAAc;AACzBjB,QAAAA,IAAI,EAAE,KAAKI,IADc;AAEzBH,QAAAA,IAAI,EAAE,KAAKI,KAFc;AAGzBH,QAAAA,GAAG,EAAE,KAAKI,IAAL,CAAUQ,mBAAV;AAHoB,OAAd,CAAb;AAKD;;AAED,WAAOP,MAAM,CAACW,MAAP,CAAc,EAAd,EAAkB,KAAKF,KAAvB,CAAP;AACD,GArCW,CAuCZ;AACA;AACA;;;AACgB,MAAZG,YAAY,GAAI;AAClB,QAAI,KAAKV,QAAL,IAAiB,IAArB,EAA2B;AACzB,aAAO,KAAKA,QAAZ;AACD;;AAED,SAAKA,QAAL,GAAgBZ,oBAAoB,CAAC,KAAKO,IAAN,CAApC;AACA,WAAO,KAAKK,QAAZ;AACD;;AAjDW;;AAoDdW,MAAM,CAACC,OAAP,GAAiBvB,OAAjB","sourcesContent":["'use strict'\n\nconst CID = require('cids')\nconst uint8ArrayFromString = require('uint8arrays/from-string')\n\n/**\n * Link represents an IPFS Merkle DAG Link between Nodes.\n */\nclass DAGLink {\n  /**\n   * @param {string | undefined | null} name\n   * @param {number} size\n   * @param {CID | string | Uint8Array} cid\n   */\n  constructor (name, size, cid) {\n    if (!cid) {\n      throw new Error('A link requires a cid to point to')\n    }\n\n    // assert(size, 'A link requires a size')\n    //  note - links should include size, but this assert is disabled\n    //  for now to maintain consistency with go-ipfs pinset\n    this.Name = name || ''\n    this.Tsize = size\n    this.Hash = new CID(cid)\n\n    Object.defineProperties(this, {\n      _nameBuf: { value: null, writable: true, enumerable: false }\n    })\n  }\n\n  toString () {\n    return `DAGLink <${this.Hash.toBaseEncodedString()} - name: \"${this.Name}\", size: ${this.Tsize}>`\n  }\n\n  toJSON () {\n    if (!this._json) {\n      this._json = Object.freeze({\n        name: this.Name,\n        size: this.Tsize,\n        cid: this.Hash.toBaseEncodedString()\n      })\n    }\n\n    return Object.assign({}, this._json)\n  }\n\n  // Memoize the Uint8Array representation of name\n  // We need this to sort the links, otherwise\n  // we will reallocate new Uint8Arrays every time\n  get nameAsBuffer () {\n    if (this._nameBuf != null) {\n      return this._nameBuf\n    }\n\n    this._nameBuf = uint8ArrayFromString(this.Name)\n    return this._nameBuf\n  }\n}\n\nmodule.exports = DAGLink\n"]},"metadata":{},"sourceType":"script"}